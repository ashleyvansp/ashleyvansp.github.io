I"˝<p>‚Ä¢	We all are interested in writing ‚Äúgood‚Äù code
‚Ä¢	This might include writing unit tests, including descriptive comments, and organizing code into logical sections to make it more readable
‚Ä¢	In general we strive for a cohesive, robust codebase
‚Ä¢	It turns out that a lot of these things can be automated by git hooks</p>

<h3 id="what-are-hooks">What are hooks?</h3>
<p>Git hooks are scripts that git executes automatically when triggered by events such as a commit or a push
‚Ä¢	The sample scripts provided by Git are bash shell scripts, but they can be written in any scripting language as long as it can be run as an executable</p>

<p>‚Ä¢	Hooks can be powerful tools with a wide range of functionality
‚Ä¢	Can cover ‚Äúgrammar police‚Äù tasks such as following naming conventions and checking for trailing whitespace
‚Ä¢	Critical tasks such as unreachable code and using uninitialized variables
‚Ä¢	Run unit testing suites
‚Ä¢	Sending an email notification if the repository is updated</p>

<p>‚Ä¢	Thinking about a continuous integration workflow, we see that different tasks for a hook make sense at different places
‚Ä¢	For instance, if you want a hook that ensures that commit messages are capitalized, you would want it to execute immediately after the user enters the commit message
‚Ä¢	Git has identified the 12 possible places in the workflow where a hook can execute, and these are specified by the name of the file in the hooks directory</p>

<p>‚Ä¢	Hooks are local to a Git repository, and they are not copied over to the new repository when you run git clone
‚Ä¢	They also aren‚Äôt under version control
‚Ä¢	So it can be challenging to keep them synchronized across team members
‚Ä¢	However, there are ways to regulate this
‚Ä¢	Hook scripts can be stored in the actual project directory and installed with either a symlink or a simple copy-paste
‚Ä¢	Client-side hooks can best be used for two purposes
o	Commit-related tasks such as code or commit message formatting
o	Notification tasks such as emailing collaborators when changes are made
‚Ä¢	But there‚Äôs also functionality with checking out or merging</p>

<p>‚Ä¢	Since client-side hooks can be modified (or even removed) by the developer in their local repository, they can‚Äôt be used to enforce coding standards, only to facilitate good coding practices
‚Ä¢	However, server-side hooks can be a safeguard against the rebellious developer by rejecting any commits that do not meet specified standards
‚Ä¢	This is the primary purpose of server-side hooks, and they‚Äôre most useful on large projects
‚Ä¢	Good for regulating who is allowed to push to the repo, the format of the commit message, or the changes contained in the commit</p>

<p>‚Ä¢	Here‚Äôs a very basic example
‚Ä¢	I have a git repository for a hello world program
‚Ä¢	Say that I want to change it to say good morning instead
‚Ä¢	Then I have a simple pre-commit hook in that .git/hooks folder. Suppose your company suspects that the rival company is sneaking into your office in the night and forging bad commits on employees‚Äô computers. To defend against this, the obvious thing to do is add a secret password before allowing commits.
‚Ä¢	I chose to use my favourite scripting language and changed the shebang to reflect that I‚Äôd be using Python instead of Bash
‚Ä¢	I‚Äôd like to take input from the developer, but hooks are typically noninteractive. So on line 6, I redirect standard input to the terminal.
‚Ä¢	Then I ask for the secret password and exit with success or failure depending on whether the password is correct</p>

:ET